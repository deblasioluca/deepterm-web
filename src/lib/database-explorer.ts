import { Prisma } from '@prisma/client';
import { prisma } from '@/lib/prisma';

// --- Types ---

export interface ModelFieldInfo {
  name: string;
  type: string;
  kind: string;
  isId: boolean;
  isRequired: boolean;
  isList: boolean;
  isUnique: boolean;
  hasDefaultValue: boolean;
  isReadOnly: boolean;
  isRelation: boolean;
  relationName?: string;
  relationFromFields?: string[];
  isSensitive: boolean;
}

export interface ModelInfo {
  name: string;
  dbName: string | null;
  fields: ModelFieldInfo[];
  scalarFields: ModelFieldInfo[];
  idField: string;
  isProtected: boolean;
}

// --- Constants ---

const SENSITIVE_FIELDS = new Set([
  'passwordHash',
  'masterPasswordHash',
  'encryptedData',
  'encryptedPrivateKey',
  'protectedSymmetricKey',
  'encryptedKey',
  'encryptedOrgKey',
  'twoFactorSecret',
  'twoFactorBackupCodes',
  'tokenHash',
  'publicKey',
]);

const PROTECTED_MODELS = new Set(['AdminUser', 'AdminPasskey']);

const TEXTAREA_FIELDS = new Set([
  'description',
  'content',
  'summary',
  'body',
  'metadata',
  'details',
  'errorLog',
  'thinking',
  'action',
  'observation',
  'systemPrompt',
  'releaseNotes',
  'notes',
  'message',
  'context',
  'output',
  'stackTrace',
  'responseBody',
  'requestBody',
]);

// --- DMMF Introspection ---

export function getAllModels(): ModelInfo[] {
  return Prisma.dmmf.datamodel.models.map((model) => {
    const fields: ModelFieldInfo[] = model.fields.map((f) => ({
      name: f.name,
      type: f.type,
      kind: f.kind,
      isId: f.isId,
      isRequired: f.isRequired,
      isList: f.isList,
      isUnique: f.isUnique,
      hasDefaultValue: f.hasDefaultValue,
      isReadOnly: f.isReadOnly,
      isRelation: f.kind === 'object',
      relationName: f.relationName || undefined,
      relationFromFields: f.relationFromFields?.length ? f.relationFromFields as string[] : undefined,
      isSensitive: SENSITIVE_FIELDS.has(f.name),
    }));

    const scalarFields = fields.filter((f) => !f.isRelation);
    const idField = scalarFields.find((f) => f.isId)?.name || 'id';

    return {
      name: model.name,
      dbName: model.dbName || null,
      fields,
      scalarFields,
      idField,
      isProtected: PROTECTED_MODELS.has(model.name),
    };
  });
}

export function getModelInfo(modelName: string): ModelInfo | null {
  return getAllModels().find((m) => m.name === modelName) || null;
}

// --- Dynamic Prisma Delegate Access ---

interface PrismaDelegate {
  findMany: (args?: Record<string, unknown>) => Promise<Record<string, unknown>[]>;
  findUnique: (args: Record<string, unknown>) => Promise<Record<string, unknown> | null>;
  count: (args?: Record<string, unknown>) => Promise<number>;
  create: (args: Record<string, unknown>) => Promise<Record<string, unknown>>;
  update: (args: Record<string, unknown>) => Promise<Record<string, unknown>>;
  delete: (args: Record<string, unknown>) => Promise<Record<string, unknown>>;
}

export function getDelegate(modelName: string): PrismaDelegate | null {
  const key = modelName.charAt(0).toLowerCase() + modelName.slice(1);
  const delegate = (prisma as unknown as Record<string, unknown>)[key];
  if (delegate && typeof (delegate as PrismaDelegate).findMany === 'function') {
    return delegate as PrismaDelegate;
  }
  return null;
}

// --- Search ---

export function buildSearchWhere(model: ModelInfo, search: string): Record<string, unknown> | undefined {
  if (!search.trim()) return undefined;
  const stringFields = model.scalarFields.filter(
    (f) => f.type === 'String' && !f.isSensitive
  );
  if (stringFields.length === 0) return undefined;
  return {
    OR: stringFields.map((f) => ({ [f.name]: { contains: search.trim() } })),
  };
}

// --- Sanitization ---

export function sanitizeRecord(record: Record<string, unknown>, model: ModelInfo): Record<string, unknown> {
  const result = { ...record };
  for (const field of model.scalarFields) {
    if (field.isSensitive && result[field.name] != null) {
      result[field.name] = '[REDACTED]';
    }
  }
  return result;
}

// --- Value Coercion ---

export function coerceValue(value: unknown, fieldType: string, isRequired: boolean): unknown {
  if (value === null || value === undefined || value === '') {
    return isRequired ? value : null;
  }
  switch (fieldType) {
    case 'Int':
      return parseInt(String(value), 10);
    case 'Float':
    case 'Decimal':
      return parseFloat(String(value));
    case 'Boolean':
      return value === true || value === 'true';
    case 'DateTime':
      return new Date(String(value));
    default:
      return value;
  }
}

// --- Field Helpers ---

export function isTextareaField(fieldName: string): boolean {
  return TEXTAREA_FIELDS.has(fieldName);
}

export function isAutoGeneratedField(field: ModelFieldInfo): boolean {
  return (
    (field.isId && field.hasDefaultValue) ||
    field.name === 'createdAt' ||
    field.name === 'updatedAt' ||
    field.isReadOnly
  );
}
