'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui';
import { Loader2 } from 'lucide-react';
import type { ModelFieldInfo } from '@/lib/database-explorer';

interface ModelInfo {
  name: string;
  scalarFields: ModelFieldInfo[];
  idField: string;
  isProtected: boolean;
}

const TEXTAREA_FIELDS = new Set([
  'description', 'content', 'summary', 'body', 'metadata', 'details',
  'errorLog', 'thinking', 'action', 'observation', 'systemPrompt',
  'releaseNotes', 'notes', 'message', 'context', 'output', 'stackTrace',
  'responseBody', 'requestBody',
]);

interface RecordFormProps {
  schema: ModelInfo;
  mode: 'create' | 'edit';
  initialData?: Record<string, unknown>;
  onSubmit: (data: Record<string, unknown>) => void;
  onCancel: () => void;
  isSubmitting: boolean;
}

function isAutoGenerated(field: ModelFieldInfo): boolean {
  return (
    (field.isId && field.hasDefaultValue) ||
    field.name === 'createdAt' ||
    field.name === 'updatedAt' ||
    field.isReadOnly
  );
}

function isFieldReadOnlyInEdit(field: ModelFieldInfo): boolean {
  return field.isId || field.name === 'createdAt' || field.isReadOnly || field.isSensitive;
}

function getInitialValue(field: ModelFieldInfo, existing?: unknown): string {
  if (existing !== undefined && existing !== null && existing !== '[REDACTED]') {
    if (field.type === 'DateTime') {
      try {
        const d = new Date(String(existing));
        return d.toISOString().slice(0, 16);
      } catch {
        return '';
      }
    }
    if (field.type === 'Boolean') return String(existing);
    return String(existing);
  }
  if (field.type === 'Boolean') return 'false';
  return '';
}

export default function RecordForm({ schema, mode, initialData, onSubmit, onCancel, isSubmitting }: RecordFormProps) {
  const editableFields = schema.scalarFields.filter((f) => {
    if (f.isSensitive) return false;
    if (mode === 'create') return !isAutoGenerated(f);
    return true;
  });

  const [formData, setFormData] = useState<Record<string, string>>({});

  useEffect(() => {
    const initial: Record<string, string> = {};
    for (const field of editableFields) {
      initial[field.name] = getInitialValue(field, initialData?.[field.name]);
    }
    setFormData(initial);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [schema.name, mode, initialData]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const data: Record<string, unknown> = {};
    for (const field of editableFields) {
      if (mode === 'edit' && isFieldReadOnlyInEdit(field)) continue;
      const val = formData[field.name];
      if (val === undefined) continue;

      if (val === '' && !field.isRequired) {
        data[field.name] = null;
      } else if (field.type === 'Boolean') {
        data[field.name] = val === 'true';
      } else if (field.type === 'Int') {
        data[field.name] = val ? parseInt(val, 10) : null;
      } else if (field.type === 'Float' || field.type === 'Decimal') {
        data[field.name] = val ? parseFloat(val) : null;
      } else {
        data[field.name] = val;
      }
    }
    onSubmit(data);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4 max-h-[60vh] overflow-y-auto pr-2">
      {editableFields.map((field) => {
        const readOnly = mode === 'edit' && isFieldReadOnlyInEdit(field);
        const value = formData[field.name] ?? '';
        const isTextarea = TEXTAREA_FIELDS.has(field.name);

        return (
          <div key={field.name}>
            <label className="block text-sm font-medium text-text-secondary mb-1">
              {field.name}
              {field.isRequired && !field.hasDefaultValue && (
                <span className="text-accent-danger ml-1">*</span>
              )}
              <span className="text-text-tertiary font-normal ml-2 text-xs">
                {field.type}{!field.isRequired ? '?' : ''}
              </span>
            </label>

            {field.type === 'Boolean' ? (
              <select
                value={value}
                onChange={(e) => setFormData((p) => ({ ...p, [field.name]: e.target.value }))}
                disabled={readOnly}
                className="w-full bg-background-primary border border-border rounded-lg px-3 py-2 text-sm text-text-primary disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-accent-primary"
              >
                <option value="false">false</option>
                <option value="true">true</option>
              </select>
            ) : field.type === 'DateTime' ? (
              <input
                type="datetime-local"
                value={value}
                onChange={(e) => setFormData((p) => ({ ...p, [field.name]: e.target.value }))}
                disabled={readOnly}
                className="w-full bg-background-primary border border-border rounded-lg px-3 py-2 text-sm text-text-primary disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-accent-primary"
              />
            ) : field.type === 'Int' || field.type === 'Float' || field.type === 'Decimal' ? (
              <input
                type="number"
                step={field.type === 'Int' ? '1' : '0.01'}
                value={value}
                onChange={(e) => setFormData((p) => ({ ...p, [field.name]: e.target.value }))}
                disabled={readOnly}
                className="w-full bg-background-primary border border-border rounded-lg px-3 py-2 text-sm text-text-primary disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-accent-primary"
              />
            ) : isTextarea ? (
              <textarea
                value={value}
                onChange={(e) => setFormData((p) => ({ ...p, [field.name]: e.target.value }))}
                disabled={readOnly}
                rows={3}
                className="w-full bg-background-primary border border-border rounded-lg px-3 py-2 text-sm text-text-primary disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-accent-primary resize-y"
              />
            ) : (
              <input
                type="text"
                value={value}
                onChange={(e) => setFormData((p) => ({ ...p, [field.name]: e.target.value }))}
                disabled={readOnly}
                className="w-full bg-background-primary border border-border rounded-lg px-3 py-2 text-sm text-text-primary disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-accent-primary"
              />
            )}
          </div>
        );
      })}

      <div className="flex justify-end gap-3 pt-4 border-t border-border">
        <Button variant="ghost" size="sm" type="button" onClick={onCancel} disabled={isSubmitting}>
          Cancel
        </Button>
        <Button variant="primary" size="sm" type="submit" disabled={isSubmitting}>
          {isSubmitting ? (
            <span className="flex items-center gap-2">
              <Loader2 className="w-3.5 h-3.5 animate-spin" />
              Saving...
            </span>
          ) : (
            mode === 'create' ? 'Create Record' : 'Save Changes'
          )}
        </Button>
      </div>
    </form>
  );
}
